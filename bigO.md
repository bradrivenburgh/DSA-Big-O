# Big O Drills

## What is the Big O for this?
1. O(1)
2. O(n)

## Even or odd
- O(1)
- The remainder of the value is either 0 or not and takes the same amount of time to return a value.

## Are you here?
- O(n^2)
- The function requires passing over the array twice with nested for loops.

## Doubler
- O(n)
- It is performing a simple operation on each element of an array; running time is relates to the length of the array in a 1:1 fashion.

## Naive search
- O(n)
- The function loops over an array one item at a time until it finds "item" so, in the worst case scenario with "item" not being in the array, it would evaluate each item in the array.  The length of the array relates to its time complexity in a 1:1 fashion.

## Creating pairs
- O(n^2)
- The nested for loops evaluate the array twice.

## Compute the sequence
- It creates a fibonacci sequence
- O(n)
- It's performing simple arithmetic and only loops through an array once.

## An efficient search
- O(log n)
- It divides the problem size in half each round through.

## Random element
- O(1)
- Returning an array index will always take the same amount of time.

## What Am I?
- Identifies prime numbers
- O(n)
- A single for loop that loops n times.

## Tower of Hanoi
- After 7 recursive calls:
-- Rod A (top-to-bottom) has disks 3, 4, 5
-- Rod B has disk 1, 2
-- Rod C has no disks
- Moves needed to complete with:
-- 5 disks: 31
-- 4 disks: 15
-- 3 disks: 7
- Time Complexity is Exponential Time O(2^n) since it takes it takes 3 moves to complete the game with 3 disks, and 1023 moves to complete the game with 10 disks.

## Counting Sheep Iterative
-- O(n) because it performs behavior once per cycle through while loop; 1:1 to value:time

## Power Calculator Iterative
-- O(n)

## Reverse String Iterative
-- O(n)

## Triangular Number Iterative
-- O(n)

## String Splitter Iterative
-- O(n)

## Fibonacci Iterative
-- O(n)

## Factorial Iterative
-- O(n)

## Recursive Big O
1. 
2. 
3. 
4. 
5. 
6. 
7.
8. 
9. 
10. 
11. 
12. 